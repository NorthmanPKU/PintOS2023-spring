# Project 0: Getting Real

## Preliminaries

>Fill in your name and email address.

Jianan Ji <2000012995@stu.pku.edu.cn>

>If you have any preliminary comments on your submission, notes for the TAs, please give them here.

**I have handled special input such as backspace.**


>Please cite any offline or online sources you consulted while preparing your submission, other than the Pintos documentation, course text, lecture notes, and course staff.

https://en.wikipedia.org/wiki/BIOS_interrupt_call


## Booting Pintos

>A1: Put the screenshot of Pintos running example here.

QEMU
![Screenshot 2023-03-02 at 17.45.17](/Users/jiananji/Desktop/大学/学业/大三下/操作系统/pintos/docs/Screenshot 2023-03-02 at 17.45.17.png)

Bochs
![Screenshot 2023-03-02 at 17.46.55](/Users/jiananji/Desktop/大学/学业/大三下/操作系统/pintos/docs/Screenshot 2023-03-02 at 17.46.55.png)

## Debugging

#### QUESTIONS: BIOS 

>B1: What is the first instruction that gets executed?

ljmp   $0x3630,$0xf000e05b


>B2: At which physical address is this instruction located?

0xffff0

#### QUESTIONS: BOOTLOADER

>B3: How does the bootloader read disk sectors? In particular, what BIOS interrupt is used?

0x13h->0x42h Extended Read Sectors

>B4: How does the bootloader decides whether it successfully finds the Pintos kernel?

![Screenshot 2023-03-02 at 20.00.12](/Users/jiananji/Desktop/大学/学业/大三下/操作系统/pintos/docs/Screenshot 2023-03-02 at 20.00.12.png)

在如图所示的位置可见，bootloader对一个partition会逐一检查是否被使用、是否是Pintos Kernel（方法是看值是否为0x20）、是否bootable（看值是否为0x80），不满足就会检查下一个partition直到找到为止。

>B5: What happens when the bootloader could not find the Pintos kernel?

![Screenshot 2023-03-02 at 20.04.56](/Users/jiananji/Desktop/大学/学业/大三下/操作系统/pintos/docs/Screenshot 2023-03-02 at 20.04.56.png)

如果所有drive和partition都没有找到的话，将进入如图所示的no_boot_partition。首先输出“Not found”，然后触发中断0x18（Execute Cassette BASIC）

>B6: At what point and how exactly does the bootloader transfer control to the Pintos kernel?

![Screenshot 2023-03-02 at 20.22.07](/Users/jiananji/Desktop/大学/学业/大三下/操作系统/pintos/docs/Screenshot 2023-03-02 at 20.22.07.png)

在如图所示的位置，168行跳转到start，bootloader转移control

#### QUESTIONS: KERNEL

>B7: At the entry of pintos_init(), what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?

![Screenshot 2023-03-02 at 20.29.23](/Users/jiananji/Desktop/大学/学业/大三下/操作系统/pintos/docs/Screenshot 2023-03-02 at 20.29.23.png)

0

>B8: When `palloc_get_page()` is called for the first time,

>> B8.1 what does the call stack look like?
>>
>>![Screenshot 2023-03-02 at 20.36.17](/Users/jiananji/Desktop/大学/学业/大三下/操作系统/pintos/docs/Screenshot 2023-03-02 at 20.36.17.png)
>> 

>> B8.2 what is the return value in hexadecimal format?
>>
>> ![Screenshot 2023-03-02 at 20.37.07](/Users/jiananji/Desktop/大学/学业/大三下/操作系统/pintos/docs/Screenshot 2023-03-02 at 20.37.07.png)
(void *) 0xc0101000

>> B8.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?
>>
>> ![Screenshot 2023-03-05 at 02.11.01](/Users/jiananji/Desktop/大学/学业/大三下/操作系统/pintos/docs/Screenshot 2023-03-05 at 02.11.01.png)
>>0

>B9: When palloc_get_page() is called for the third time,

>> B9.1 what does the call stack look like?

\#0  palloc_get_page (flags=PAL_ZERO) at ../../threads/palloc.c:112

\#1  0xc0020a81 in thread_create (name=0xc002e895 "idle", priority=0, function=0xc0020eb0 <idle>, aux=0xc000efbc）at ../../threads/thread.c:178

\#2  0xc0020976 in thread_start () at ../../threads/thread.c:111

\#3  0xc0020334 in pintos_init () at ../../threads/init.c:119

\#4  0xc002013d in start () at ../../threads/start.S:180

>> B9.2 what is the return value in hexadecimal format?
>>
(void *) 0xc0103000



>> B9.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?
>>
0x102027



## Kernel Monitor

>C1: Put the screenshot of your kernel monitor running example here. (It should show how your kernel shell respond to `whoami`, `exit`, and `other input`.)

#### 
![Screenshot 2023-03-02 at 22.24.12](/Users/jiananji/Desktop/大学/学业/大三下/操作系统/pintos/docs/Screenshot 2023-03-02 at 22.24.12.png)



>C2: Explain how you read and write to the console for the kernel monitor.

读：循环，用input_getc一个字符一个字符读取，读到回车跳转到处理阶段，读到可打印字符在没有超出上限的情况下存入字符串并打印出字符，读到退格则将字符串最后一位变为"\0"并用printf("\b \b")的方式在terminal中实现退格。

处理：判断字符串，若为“whoami”则输出学号2000012995，若为“exit”则退出，其他情况输出“invalid input”。除“exit”外，其他情况都要继续循环回到读阶段。

